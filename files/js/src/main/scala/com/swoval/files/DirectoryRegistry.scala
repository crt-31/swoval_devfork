// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import java.util.Map.Entry
import com.swoval.functional.Filter
import java.nio.file.Path
import java.util.Collections
import java.util.HashMap
import java.util.Iterator
import java.util.Map
import java.util.concurrent.ConcurrentHashMap
import DirectoryRegistryImpl._

/**
 * Tracks which directories the user wishes to monitor. This can be used to determine whether or not
 * a path is part of the subtree specified by the set of paths registered by the user.
 */
trait DirectoryRegistry extends Filter[Path] with AutoCloseable {

  /**
   * Add the input directory to the list of registered directories.
   *
   * @param path the directory to register
   * @param maxDepth controls how many levels of the children of the path should be monitored
   * @return true if the directory has not been previously registered before or if the new maxDepth
   *     value is greater than the previous value.
   */
  def addDirectory(path: Path, maxDepth: Int): Boolean

  /**
   * The maximum depth of children of the path to accept.
   *
   * @param path the registered path
   * @return the maximum depth of children if the path has been registered. Otherwise it returns
   *     Integer.MIN_VALUE.
   */
  def maxDepthFor(path: Path): Int

  /**
   * Returns a map of Path -> maxDepth for each path.
   *
   * @return a map of Path -> maxDepth for each path.
   */
  def registered(): Map[Path, Integer]

  /**
   * Remove the path from monitoring.
   *
   * @param path the path to stop monitoring.
   */
  def removeDirectory(path: Path): Unit

  /**
   * Returns true if this path is a prefix of a registered path. The intended use case is for the
   * [[NioPathWatcher]] which always has the root directory as the base. This is so that we can
   * ensure that if we register a directory that does not yet exist, that we will detect when the
   * directory is created. For example, if we want to monitor '/foo/bar/baz', then we would accept
   * '/foo/bar' as a valid prefix path, but we would not accept '/foo/buzz' as a valid prefix path.
   *
   * @param path the path to compare against the registered path
   * @return true if the path is a prefix of a registered path.
   */
  def acceptPrefix(path: Path): Boolean

  override def close(): Unit

}

object DirectoryRegistries {

  def toTypedPathFilter(registry: DirectoryRegistry): Filter[TypedPath] =
    new Filter[TypedPath]() {
      override def accept(typedPath: TypedPath): Boolean =
        registry.accept(typedPath.getPath)
    }

}

object DirectoryRegistryImpl {

  private class RegisteredDirectory(val path: Path, val maxDepth: Int) {

    val compMaxDepth: Int =
      if (maxDepth == java.lang.Integer.MAX_VALUE) maxDepth else maxDepth + 1

    def accept(path: Path): Boolean =
      path.startsWith(this.path) &&
        (path == this.path ||
          this.path.relativize(path).getNameCount <= compMaxDepth)

    override def toString(): String =
      "RegisteredDirectory(path = " + path + ", depth = " +
        maxDepth +
        ")"

  }

}

class DirectoryRegistryImpl extends DirectoryRegistry {

  private val registeredDirectoriesByPath: LockableMap[Path, RegisteredDirectory] =
    new LockableMap(new ConcurrentHashMap[Path, RegisteredDirectory]())

  override def addDirectory(path: Path, maxDepth: Int): Boolean =
    if (registeredDirectoriesByPath.lock()) {
      try {
        val registeredDirectory: RegisteredDirectory =
          registeredDirectoriesByPath.get(path)
        if (registeredDirectory == null || maxDepth > registeredDirectory.maxDepth) {
          registeredDirectoriesByPath.put(path, new RegisteredDirectory(path, maxDepth))
          true
        } else {
          false
        }
      } finally registeredDirectoriesByPath.unlock()
    } else {
      false
    }

  override def maxDepthFor(path: Path): Int =
    if (registeredDirectoriesByPath.lock()) {
      try {
        var maxDepth: Int = java.lang.Integer.MIN_VALUE
        val it: Iterator[RegisteredDirectory] =
          registeredDirectoriesByPath.values.iterator()
        while (it.hasNext) {
          val dir: RegisteredDirectory = it.next()
          if (path.startsWith(dir.path)) {
            val depth: Int =
              if (dir.path == path) 0
              else dir.path.relativize(path).getNameCount
            val possibleMaxDepth: Int = dir.maxDepth - depth
            if (possibleMaxDepth > maxDepth) {
              maxDepth = possibleMaxDepth
            }
          }
        }
        maxDepth
      } finally registeredDirectoriesByPath.unlock()
    } else {
      -1
    }

  override def registered(): Map[Path, Integer] =
    if (registeredDirectoriesByPath.lock()) {
      try {
        val result: Map[Path, Integer] = new HashMap[Path, Integer]()
        val it: Iterator[RegisteredDirectory] =
          registeredDirectoriesByPath.values.iterator()
        while (it.hasNext) {
          val dir: RegisteredDirectory = it.next()
          result.put(dir.path, dir.maxDepth)
        }
        result
      } finally registeredDirectoriesByPath.unlock()
    } else {
      Collections.emptyMap()
    }

  override def removeDirectory(path: Path): Unit = {
    if (registeredDirectoriesByPath.lock()) {
      try registeredDirectoriesByPath.remove(path)
      finally registeredDirectoriesByPath.unlock()
    }
  }

  private def acceptImpl(path: Path, acceptPrefix: Boolean): Boolean =
    if (registeredDirectoriesByPath.lock()) {
      try {
        var result: Boolean = false
        val it: Iterator[Entry[Path, RegisteredDirectory]] =
          registeredDirectoriesByPath.iterator()
        while (!result && it.hasNext) {
          val entry: Entry[Path, RegisteredDirectory] = it.next()
          val registeredDirectory: RegisteredDirectory = entry.getValue
          val watchPath: Path = entry.getKey
          if (acceptPrefix && watchPath.startsWith(path)) {
            result = true
          } else if (path.startsWith(watchPath)) {
            result = registeredDirectory.accept(path)
          }
        }
        result
      } finally registeredDirectoriesByPath.unlock()
    } else {
      false
    }

  override def accept(path: Path): Boolean = acceptImpl(path, false)

  override def acceptPrefix(path: Path): Boolean = acceptImpl(path, true)

  override def close(): Unit = {
    registeredDirectoriesByPath.clear()
  }

  override def toString(): String =
    if (registeredDirectoriesByPath.lock()) {
      try {
        val result: StringBuilder = new StringBuilder()
        result.append("DirectoryRegistry:\n")
        val it: Iterator[RegisteredDirectory] =
          registeredDirectoriesByPath.values.iterator()
        while (it.hasNext) {
          result.append("  ")
          result.append(it.next())
          result.append('\n')
        }
        result.toString
      } finally registeredDirectoriesByPath.unlock()
    } else {
      ""
    }

}
